npm install --save-dev supertest jest


unit -> eventModel.test.js


require('dotenv').config();
const mongoose = require('mongoose');
const Event = require('../../models/Event');

describe('Event Model Validation', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.TEST_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  it('should require title, date, and location', () => {
    const event = new Event({});
    const validationError = event.validateSync();

    expect(validationError.errors['title']).toBeDefined();
    expect(validationError.errors['date']).toBeDefined();
    expect(validationError.errors['location']).toBeDefined();
  });
});
---------------------------------------------------------------------------------------------------------------


require('dotenv').config();
const request = require('supertest');
const mongoose = require('mongoose');
const app = require('../../app'); // Your Express app

describe('POST /api/v1/attendees', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.TEST_MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  it('should register attendee successfully', async () => {
    // Sample attendee data
    const attendeeData = {
      userId: '645f7b9c7a1c1234a0b67890', // Replace with a valid user ID from your DB
      eventId: '645f7a4c1a5f8e23a1c89012', // Replace with a valid event ID from your DB
    };

    const res = await request(app)
      .post('/api/v1/attendees')
      .set('Authorization', 'Bearer <Attendee_Access_Token>') // Replace with a valid JWT
      .send(attendeeData);

    expect(res.statusCode).toEqual(200);
    expect(res.body.success).toBe(true);
    expect(res.body.data).toHaveProperty('_id');
    expect(res.body.data.user).toBe(attendeeData.userId);
    expect(res.body.data.event).toBe(attendeeData.eventId);
  });
});



eventController.js


const Event = require('../models/Event');
const logger = require('../config/logger');

exports.createEvent = async (req, res) => {
  try {
    const { title, description, date, location } = req.body;

    // Allow Organizer and Attendee to create events
    if (!['Organizer', 'Attendee'].includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'Forbidden: Only Organizer or Attendee can create events' });
    }

    const event = await Event.create({
      title,
      description,
      date,
      location,
      organizer: req.user.id
    });

    logger.info(`Event created by ${req.user.role}: ${req.user.id}`);
    res.status(201).json({
      success: true,
      message: 'Event created successfully',
      data: event
    });
  } catch (error) {
    logger.error(`Event creation failed: ${error.message}`);
    res.status(500).json({ success: false, message: error.message });
  }
};
------------------------------------------------------------------------------------------------------------------
attendeeController.js


const Attendee = require('../models/Attendee');
const Event = require('../models/Event');
const User = require('../models/User');
const logger = require('../config/logger');

exports.registerAttendee = async (req, res) => {
  try {
    const { userId, eventId } = req.body;

    const user = await User.findById(userId);
    const event = await Event.findById(eventId);

    if (!user) {
      logger.warn(`Attendee registration failed: User not found (${userId})`);
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    if (!event) {
      logger.warn(`Attendee registration failed: Event not found (${eventId})`);
      return res.status(404).json({ success: false, message: 'Event not found' });
    }

    const attendee = await Attendee.create({ user: userId, event: eventId });
    logger.info(`Attendee registered: User ${userId} for Event ${eventId}`);

    res.status(201).json({
      success: true,
      message: 'Registration successful',
      data: attendee
    });
  } catch (error) {
    logger.error(`Attendee registration error: ${error.message}`);
    res.status(500).json({ success: false, message: error.message });
  }
};
-----------------------------------------------------------------------------------------
eventRoutes.js

const express = require('express');
const { createEvent } = require('../controllers/eventController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

// Allow Organizer and Attendee to create events
router.post('/', authMiddleware(['Organizer', 'Attendee']), createEvent);

module.exports = router;
-----------------------------------------------------------------------------------------
attendeeRoutes.js

const express = require('express');
const { registerAttendee } = require('../controllers/attendeeController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

// Allow Attendee to register for events
router.post('/', authMiddleware(['Attendee']), registerAttendee);

module.exports = router;
------------------------------------------------------------


authController



const bcrypt = require('bcryptjs'); // Using bcryptjs for simplicity
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const logger = require('../config/logger');

exports.register = async (req, res) => {
  try {
    const { name, email, password, role } = req.body;

    // ✅ Hash the password before saving
    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await User.create({
      name,
      email,
      password: hashedPassword,
      role
    });

    logger.info(`User registered successfully: ${email}`);
    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    logger.error(`Registration failed: ${error.message}`);
    res.status(500).json({ success: false, message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) {
      logger.warn(`Login failed: User not found (${email})`);
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // ✅ Compare entered password with hashed password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      logger.warn(`Login failed: Password mismatch for ${email}`);
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // ✅ Generate JWT token
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    logger.info(`Login successful: ${email}`);
    res.json({ success: true, token });
  } catch (error) {
    logger.error(`Login error: ${error.message}`);
    res.status(500).json({ success: false, message: error.message });
  }
};


--------------------------------
db.js

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection failed:', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;

-------------------------------------------------------------------------------------------
looger.js

const { createLogger, format, transports } = require('winston');

const logger = createLogger({
  level: 'info',
  format: format.combine(
    format.timestamp(),
    format.json()
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/app.log' })
  ]
});

module.exports = logger;

-------------------------------------------------------------------------------------------
attendeeController.js


const Attendee = require('../models/Attendee');
const logger = require('../config/logger');

exports.registerAttendee = async (req, res, next) => {
  try {
    const attendee = await Attendee.create(req.body);
    logger.info(`Attendee registered for event: ${attendee.event}`);
    res.status(201).json({ success: true, data: attendee });
  } catch (error) {
    logger.error('Attendee registration failed', { error: error.message });
    next(error);
  }
};

-------------------------------------------------------------------------------------------

authController.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const bcrypt = require('bcrypt');
const logger = require('../config/logger');

exports.register = async (req, res, next) => {
  try {
    const user = await User.create(req.body);
    logger.info(`New user registered: ${user.email}`);
    res.status(201).json({ success: true, data: user });
  } catch (error) {
    logger.error('Registration failed', { error: error.message });
    next(error);
  }
};

exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      logger.warn(`Login failed for email: ${email}`);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '1h' });
    logger.info(`User logged in: ${email}`);
    res.json({ success: true, token });
  } catch (error) {
    logger.error('Login error', { error: error.message });
    next(error);
  }
};

---------------------------------------------------------------------------------------------------
eventController.js


const Event = require('../models/Event');
const fs = require('fs');
const path = require('path');
const logger = require('../config/logger');


exports.createEvent = async (req, res) => {
  try {
    const { title, description, date, location } = req.body;

    // ✅ Allow any authenticated user (Admin, Organizer, Attendee) to create events
    const event = await Event.create({
      title,
      description,
      date,
      location,
      organizer: req.user.id // Track who created the event
    });

    res.status(201).json({
      success: true,
      message: 'Event created successfully',
      data: event
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};



const fs = require('fs');
const path = require('path');
const Event = require('../models/Event');

exports.uploadImage = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({ success: false, message: 'Event not found' });
    }

    // Save raw binary data from request body
    const fileName = `event_${Date.now()}.jpg`;
    const filePath = path.join(__dirname, '../../uploads', fileName);

    const writeStream = fs.createWriteStream(filePath);
    req.pipe(writeStream);

    writeStream.on('finish', async () => {
      event.image = fileName;
      await event.save();

      res.json({
        success: true,
        message: 'Event image uploaded successfully',
        data: {
          fileName,
          filePath: `/uploads/${fileName}`,
          uploadedAt: new Date()
        }
      });
    });

    writeStream.on('error', (err) => {
      res.status(500).json({ success: false, message: err.message });
    });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
};

------------------------------------------------------------------------------------

authMiddleware.js
const jwt = require('jsonwebtoken');

module.exports = (roles = []) => {
  return (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ success: false, message: 'No token provided' });
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      if (roles.length && !roles.includes(decoded.role)) {
        return res.status(403).json({ success: false, message: 'Forbidden' });
      }
      req.user = decoded;
      next();
    } catch (error) {
      res.status(401).json({ success: false, message: 'Invalid token' });
    }
  };
};
-------------------------------------------------------------------

eventHandler.js


const logger = require('../config/logger');

module.exports = (err, req, res, next) => {
  logger.error(err.message, { stack: err.stack });
  res.status(500).json({ success: false, message: err.message });
};

-------------------------------------------------------------------
Attendee.ja

const mongoose = require('mongoose');

const attendeeSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  event: { type: mongoose.Schema.Types.ObjectId, ref: 'Event', required: true },
  registeredAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Attendee', attendeeSchema);

-------------------------------------------------------------------------
Event.js

const mongoose = require('mongoose');

const eventSchema = new mongoose.Schema({
  title: { type: String, required: true },
  description: String,
  date: { type: Date, required: true },
  location: { type: String, required: true },
  image: String,
  organizer: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });

module.exports = mongoose.model('Event', eventSchema);


-----------------------------------------------------------------

User.js

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, enum: ['Admin', 'Organizer', 'Attendee'], default: 'Attendee' }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);

---------------------------------------------------------------------

attendeeRoutes.js


const express = require('express');
const { registerAttendee } = require('../controllers/attendeeController');
const authMiddleware = require('../middlewares/authMiddleware');
const router = express.Router();

router.post('/', authMiddleware(['Attendee']), registerAttendee);

module.exports = router;

-----------------------------------------------------------------------------
authRoutes.js




const express = require('express');
const { register, login } = require('../controllers/authController');
const router = express.Router();

router.post('/register', register);
router.post('/login', login);

module.exports = router;


-------------------------------------------------------------------------------

eventRoutes.js




const express = require('express');
const { createEvent, uploadImage } = require('../controllers/eventController');
const authMiddleware = require('../middlewares/authMiddleware');
const router = express.Router();

router.post('/', authMiddleware(['Organizer']), createEvent);
router.post('/:id/image', authMiddleware(['Organizer']), upload.single('image'), uploadImage);

module.exports = router;


------------------------------------------------------------------------------------
intrgration/sample.test.js


const request = require('supertest');
const app = require('../../app');

describe('Integration Test: Events API', () => {
  it('GET /api/v1/events should return 404 (no route for GET)', async () => {
    const res = await request(app).get('/api/v1/events');
    expect(res.statusCode).toBe(404);
  });
});

------------------------------------------------------------------------------------

emailService.js


// Placeholder for email sending logic
exports.sendEmail = async (to, subject, body) => {
  // Implement email sending using nodemailer or any service
  console.log(`Email sent to ${to}: ${subject}`);
};
-------------------------------------------------------------------------------------
fileHandler.js

const fs = require('fs');
const path = require('path');

exports.saveFileStream = (fileBuffer, fileName) => {
  const filePath = path.join('uploads', fileName);
  const stream = fs.createWriteStream(filePath);
  stream.write(fileBuffer);
  stream.end();
  return filePath;
};
---------------------------------------------------------------------------------------
app.js


const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const errorHandler = require('./src/middlewares/errorHandler');
const logger = require('./src/config/logger');

dotenv.config();
const app = express();

app.use(cors());
app.use(express.json());

// Routes
const authRoutes = require('./src/routes/authRoutes');
const eventRoutes = require('./src/routes/eventRoutes');
const attendeeRoutes = require('./src/routes/attendeeRoutes');

app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/events', eventRoutes);
app.use('/api/v1/attendees', attendeeRoutes);

// Error Handler
app.use(errorHandler);

// Log app start
logger.info('App initialized');

module.exports = app;
--------------------------------------------------------------------------------------

server.js


const app = require('./app');
const connectDB = require('./src/config/db');
const logger = require('./src/config/logger');

const PORT = process.env.PORT || 5000;

connectDB()
  .then(() => {
    app.listen(PORT, () => logger.info(`Server running on port ${PORT}`));
  })
  .catch(err => logger.error('DB Connection Failed', { error: err.message }));



















